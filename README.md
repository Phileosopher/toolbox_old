# toolbox

I've made this toolbox to accomplish several things.

## 1. Convenience

This is to make a quick-reference, at least for myself.

Since we don't write essays in machine code, _everyone_ exploits an abstraction when using computers. An OS is the equivalent of a vastly complicated multitool, but with modular pieces with use cases that range from a rocket ship to a chainsaw.

With the web, most people will download something, use it, then promptly forget about it. Then, months or years later, they'll rediscover it while researching a solution, then promptly forget it again. Repeat.

So, this thing makes my life convenient.

## 2. Awareness

I'm fairly certain many people remake existing software because they don't realize someone already made it.

Obviously, that's not *always* true:

- Refactoring is complicated, and it's often hard to find *precisely* what you want.
- Some software developers want to test to themselves/others whether they're smart.
- Sometimes it's very educational or downright *fun* to reinvent the wheel.
- If someone has severe trust issues, they'll make a de-(thing) version of that thing.

However, if I need something to stretch audio or batch-compare files, my largest mental hurdle is knowing it even *exists*. Even when a tool is obsolete, placed behind a paywall, merged into some other software suite, or just plain forgotten, that idea lives on and someone else will usually pick up the torch.

## 3. Future Convenience

I _might_ find lots of things here useful someday, but I don't feel like dragging around 4 terabytes of constantly updating programs just to know where they are.

So, this is a bit like a hoarder's barn, but collects less dust and is proportionally smaller. I will probably not use 95% of the stuff here, but I figure someone else might.

## Rules

For brevity's sake, I'm mostly glossing over a few groups:

- The built-in tools. If I need them, they're in the computer already.
- Paid tools, at least when I have to pause to consider my budget.
- Most courses and courseware, since the means of accomplishing many things in a computer are *constantly* changing technology fashions.

I've broken everything into malleable groupings, since there are *many* things that someone could use a computer for, and people are constantly adding new things. These groupings have a philosophical basis in their designed *final* purpose:

- Consuming: to experience others' created works without any creative goals in mind
- Foraging: to acquire others' creative works
- Calculators: to create a simple, usually numerical solution
- Communicating: to communicate with other people, directly or indirectly
- Hardware: to make or manage physical things, which include computer information on the OS level
- Software: to broadly make or manage conceptual things
- Visual: to visually design or adapt things which contain some intended aesthetic
- Audio: to create or manipulate sound for some intended aesthetic
- Text: to create or manipulate language for some intended aesthetic
- Productivity: to broadly streamline doing any of the above

## What it needs

- _*_ if it's something to copy-paste or a reference sheet.
- ‚òÅ for browser-based apps, ‚áâ for a browser/software plugin or extension
- Desktop: ‚äû for Windows, ‚åò for Mac OS X, üêß for Linux and Friends.
- Mobile: ü§ñ for Android, üçé for iOS.
- ‚ñ° for non-UI CLI-based tools.
- ‚ñ† for standalone files or portable Windows apps (many through [PortableApps.com](https://portableapps.com/)).
- üêç if it runs in Python

These are volatile out-of-the-box estimations for several reasons:

- If the specs are high enough (and they usually are), you can make any software run on any popular OS. Quick-and-dirty still does the job, even if it's running on an MS-DOS emulator inside a Windows XP VM.
- Developers keep making new things for new technologies, so in ten years everyone might have BlahBlahOS where everything runs on it and these won't matter.

## What I'm looking for

Please feel free to pull request if you have anything I've missed. Or, if tech's not your thing, contact me via "greg at stucky dot tech":

1. Things that are obsolete and their superior replacement.
2. Any relevant platforms/languages the tool needs (e.g., ‚äû‚ñ†‚åòüêßüçéü§ñ‚áâ).
3. Any classes or sub-classes of tool I may have missed.

Also, right now I'm *really* looking for the following:

- Free or affordable technology standards (e.g., ISO 9000)
  
If you like what you see, feel free to fork, or visit [my website](https://stucky.tech) for other useful things.
